{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Guido Project The Guido Project is an open source project hosted on github that encompasses a music notation format, a score rendering engine and various music score utilities. The Guido Music Notation Format is a general purpose formal language for representing score-level music in a platform-independent plain text and human readable way. The format comes with various software components for music score rendering and manipulation. The main of these components is the Guido engine, a library that can be embedded on different platforms and using different programming languages. The Guido Library is an efficient solution to embed music notation in a standalone application or in a web page. Interfaces are available for various programming languages: C/C++ Java Javascript Python It supports different frameworks for graphic rendering: Qt Juce Open Framework OpenGL It runs on the main operating systems and provides native graphic devices: Android iOS Linux MacOSX Windows The Guido tools include a Qt editor, various command line utilities and an online editor based on the Web Assembly flavor of the Guido Library. Compared to existing solutions in the field of music score compilation, the notable feature of the Guido engine is its efficiency and its ability to compute scores in real time. Targets The present web site is intended for: applications developers who want to embed symbolic music notation: the Guido API section documents the Guido Engine API and operations; contributors who want to extend the engine or fix some bug: the Internals section gives some insights into the engine design and implementation. See also the Contributing section on the guidolib wiki. Note that Kai Renz's PHD thesis constitutes still the most detailled description of the engine design and operations. The Guido project is an open source project hosted on github . History The Guido Project originates from the GUIDO NoteViewer project started in the 90th at the Darmstadt University of Technology by 3 PHD students: Holger H.Hoos, J\u00fcrgen Kilian and Kai Renz. Keith Hamel, the author of Notability has also significantly contributed to the project. The GUIDO NoteViewer became an open source library in December 2002 at the initiative of Grame-CNCM .","title":"Home"},{"location":"#the-guido-project","text":"The Guido Project is an open source project hosted on github that encompasses a music notation format, a score rendering engine and various music score utilities. The Guido Music Notation Format is a general purpose formal language for representing score-level music in a platform-independent plain text and human readable way. The format comes with various software components for music score rendering and manipulation. The main of these components is the Guido engine, a library that can be embedded on different platforms and using different programming languages. The Guido Library is an efficient solution to embed music notation in a standalone application or in a web page. Interfaces are available for various programming languages: C/C++ Java Javascript Python It supports different frameworks for graphic rendering: Qt Juce Open Framework OpenGL It runs on the main operating systems and provides native graphic devices: Android iOS Linux MacOSX Windows The Guido tools include a Qt editor, various command line utilities and an online editor based on the Web Assembly flavor of the Guido Library. Compared to existing solutions in the field of music score compilation, the notable feature of the Guido engine is its efficiency and its ability to compute scores in real time.","title":"The Guido Project"},{"location":"#targets","text":"The present web site is intended for: applications developers who want to embed symbolic music notation: the Guido API section documents the Guido Engine API and operations; contributors who want to extend the engine or fix some bug: the Internals section gives some insights into the engine design and implementation. See also the Contributing section on the guidolib wiki. Note that Kai Renz's PHD thesis constitutes still the most detailled description of the engine design and operations. The Guido project is an open source project hosted on github .","title":"Targets"},{"location":"#history","text":"The Guido Project originates from the GUIDO NoteViewer project started in the 90th at the Darmstadt University of Technology by 3 PHD students: Holger H.Hoos, J\u00fcrgen Kilian and Kai Renz. Keith Hamel, the author of Notability has also significantly contributed to the project. The GUIDO NoteViewer became an open source library in December 2002 at the initiative of Grame-CNCM .","title":"History"},{"location":"todo/","text":"To-Do List Improve coding rewrite elements of classes that do not yet support the coding guidelines (mainly field names), segment methods that are too long into functional sub-methods, improve the design for a more functional approach i.e. mainly avoiding side effects, mark const methods that can be put private the methods and fields that can be private (or that are close to) Documentation Improve the current documentation, especially regarding the internal part. The source and the generation process are located in the site folder of the repository. Issues you can also contribute by taking any open issues in charge. SMUFL SMUFL stands for Standard Music Font Layout. SMUFL support is currently in progress but has to be finalized. To switch to SMUFL support, SMUFL is a cmake option.","title":"To do list"},{"location":"todo/#to-do-list","text":"","title":"To-Do List"},{"location":"todo/#improve-coding","text":"rewrite elements of classes that do not yet support the coding guidelines (mainly field names), segment methods that are too long into functional sub-methods, improve the design for a more functional approach i.e. mainly avoiding side effects, mark const methods that can be put private the methods and fields that can be private (or that are close to)","title":"Improve coding"},{"location":"todo/#documentation","text":"Improve the current documentation, especially regarding the internal part. The source and the generation process are located in the site folder of the repository.","title":"Documentation"},{"location":"todo/#issues","text":"you can also contribute by taking any open issues in charge.","title":"Issues"},{"location":"todo/#smufl","text":"SMUFL stands for Standard Music Font Layout. SMUFL support is currently in progress but has to be finalized. To switch to SMUFL support, SMUFL is a cmake option.","title":"SMUFL"},{"location":"api/overview/","text":"Overview of the Guido library The Guido Engine operates on a memory representation of the Guido Music Notation format [GMN] the Guido Abstract Representation [AR]. This representation is transformed step by step to produce graphical score pages. Two kinds of processing are applied to the AR: AR to AR transformations which represents a logical layout transformation: part of the layout (such as beaming for example) may be computed from the AR as well as expressed in AR, the AR is finally converted into a Guido Graphic Representation (GR) that contains the necessary layout information and is directly used to draw the music score. This final step includes notably spacing and page breaking algorithms. See the Guido Project overview pages for a quick introduction to the library services. It gives also an overview of the score operations provided by the GuidAR library . See also the system architecture . Main services The main services provided by the library are: Parsing GMN files, strings or streams to build an AR memory representation. GMN streams are unfinished GMN representations, intended to be written on the fly, that can be handled like regular GMN files, Building AR memory representations from scratch using the Guido Factory API, Building GR representations from AR representations and controlling the graphic representation, Score drawing and page formatting , Browsing and querying music pages, Time to graphic mappings that are relations between graphic segments (rectangles) and time segments (intervals), MIDI conversion (provided that the engine has been compiled with MIDI support), Miscellaneous functions such as version number , management or timing measurements, Alternate representations: Piano Roll , Reduced proportional representation , Interfaces The Guido library API was originally designed as a C API but it's available also for the following languages: C++ : a C++ interface has been designed over the C API. Java : the Guido engine is available as a native library for Java. Thus the implementation is object oriented but the C API is globally respected: only the Guido prefix of the function names is not present in the methods names. See the java documentation . Javascript : the Guido engine is available as a Web Assembly [WASM] library for Javascript and published on NPM . The implementation is based on the C++ interface. See the javascript documentation . Python : a Python interface has been designed but has not been maintained for years. In addition, the Guido engine services are also available as Web API .","title":"Overview"},{"location":"api/overview/#overview-of-the-guido-library","text":"The Guido Engine operates on a memory representation of the Guido Music Notation format [GMN] the Guido Abstract Representation [AR]. This representation is transformed step by step to produce graphical score pages. Two kinds of processing are applied to the AR: AR to AR transformations which represents a logical layout transformation: part of the layout (such as beaming for example) may be computed from the AR as well as expressed in AR, the AR is finally converted into a Guido Graphic Representation (GR) that contains the necessary layout information and is directly used to draw the music score. This final step includes notably spacing and page breaking algorithms. See the Guido Project overview pages for a quick introduction to the library services. It gives also an overview of the score operations provided by the GuidAR library . See also the system architecture .","title":"Overview of the Guido library"},{"location":"api/overview/#main-services","text":"The main services provided by the library are: Parsing GMN files, strings or streams to build an AR memory representation. GMN streams are unfinished GMN representations, intended to be written on the fly, that can be handled like regular GMN files, Building AR memory representations from scratch using the Guido Factory API, Building GR representations from AR representations and controlling the graphic representation, Score drawing and page formatting , Browsing and querying music pages, Time to graphic mappings that are relations between graphic segments (rectangles) and time segments (intervals), MIDI conversion (provided that the engine has been compiled with MIDI support), Miscellaneous functions such as version number , management or timing measurements, Alternate representations: Piano Roll , Reduced proportional representation ,","title":"Main services"},{"location":"api/overview/#interfaces","text":"The Guido library API was originally designed as a C API but it's available also for the following languages: C++ : a C++ interface has been designed over the C API. Java : the Guido engine is available as a native library for Java. Thus the implementation is object oriented but the C API is globally respected: only the Guido prefix of the function names is not present in the methods names. See the java documentation . Javascript : the Guido engine is available as a Web Assembly [WASM] library for Javascript and published on NPM . The implementation is based on the C++ interface. See the javascript documentation . Python : a Python interface has been designed but has not been maintained for years. In addition, the Guido engine services are also available as Web API .","title":"Interfaces"},{"location":"internals/architecture/","text":"The Guido Engine Architecture The Guido Engine may be viewed as black box that takes a textual description of the music at Guido Music Notation format to produce various graphic representations as output. To do so, the engine proceeds globally in 4 steps (see also the figure below): 1) it builds a memory representation of the textual description, which we'll refer later as the Abstract Representation [AR] 2) it applies a set of transformations to the Abstract Representation , which are actually AR to AR transformations and that represents a logical layout transformation: part of the layout (such as beaming for example) may be computed from the AR as well as expressed in AR. 3) it transforms to the Abstract Representation into a Graphic Representation [GR]: the abstract objects are instanciated in the graphic space with concrete positions and dimensions. 4) the Graphic Representation is drawn using the Virtual Graphic Device layer.","title":"Global architecture"},{"location":"internals/architecture/#the-guido-engine-architecture","text":"The Guido Engine may be viewed as black box that takes a textual description of the music at Guido Music Notation format to produce various graphic representations as output. To do so, the engine proceeds globally in 4 steps (see also the figure below): 1) it builds a memory representation of the textual description, which we'll refer later as the Abstract Representation [AR] 2) it applies a set of transformations to the Abstract Representation , which are actually AR to AR transformations and that represents a logical layout transformation: part of the layout (such as beaming for example) may be computed from the AR as well as expressed in AR. 3) it transforms to the Abstract Representation into a Graphic Representation [GR]: the abstract objects are instanciated in the graphic space with concrete positions and dimensions. 4) the Graphic Representation is drawn using the Virtual Graphic Device layer.","title":"The Guido Engine Architecture"},{"location":"internals/arclasses/","text":"Abstract classes Abstract classes describe the music representation at logical level and are used to handle musical tag. Each tag has a corresponding abstract class, which name starts with AR and which is implemented in a file that carries the name of the class. For example, the \\meter tag is described by the ARMeter class, which is implemented in the ARMeter.cpp and ARMeter.h files. The main purpose of the AR classes is to store and possibly pre-process the tag parameters. Main musical concepts Almost all the AR classes represent a Guido tag. However, the main musical concepts (like notes or voices) are not based on tags but are also represented using AR classes: ARMusic : represents the score , i.e. a set of voices, ARMusicalVoice : represents a musical voice . Note that AR to AR operations are implemented by the ARMusicalVoice class, ARNote : represents notes. Utilities ARFactory : this class is in charge of the creation of all the musical elements (voices, notes, tags,...). It is used either by the parser of by the GUIDOFactory API . ARMusicalVoiceState : used to maintain the current voice state at a given location when traversing the voice. For example, a voice state contains the list of opened tags at a given voice position. AR to AR operations AR to AR operations enrich the abstract representation with elements that can be automatically computed from the current descrption (e.g. like bars). They consists also in a set of logical layout operations (e.g. compute the beam direction when not set). Theses operations are implemented in ARMusicalVoice by a set of methods named doAuto... : doAutoKeys(): traverses the voice and look for key changes. Whenever a key-change occurs, the previous key needs to be 'naturalized', doAutoDispatchLyrics(): converts lyrics tags into individual text-tags for all events within the range, doAutoTies(): traverses the voice and split ties so that there are always TWO events within a tie-Range, doAutoCheckStaffStateTags(): makes sure that clef/key/meter-information is set, doAutoDisplayCheck(): checks whether the events in the voice can be displayed as single graphical objects, doAutoBarlines(): add automatic barlines, breaks notes if needed, doAutoMeasuresNumbering(): add mesaures numbering, doAutoEndBar(): add end bar (unless prevented with an auto tag), doAutoBeaming(): add automatic beaming tags, doAutoGlissando(): post-processing for the glissando tags, doAutoFeatheredBeam(): post-processing for the fbeam tags.","title":"AR classes"},{"location":"internals/arclasses/#abstract-classes","text":"Abstract classes describe the music representation at logical level and are used to handle musical tag. Each tag has a corresponding abstract class, which name starts with AR and which is implemented in a file that carries the name of the class. For example, the \\meter tag is described by the ARMeter class, which is implemented in the ARMeter.cpp and ARMeter.h files. The main purpose of the AR classes is to store and possibly pre-process the tag parameters.","title":"Abstract classes"},{"location":"internals/arclasses/#main-musical-concepts","text":"Almost all the AR classes represent a Guido tag. However, the main musical concepts (like notes or voices) are not based on tags but are also represented using AR classes: ARMusic : represents the score , i.e. a set of voices, ARMusicalVoice : represents a musical voice . Note that AR to AR operations are implemented by the ARMusicalVoice class, ARNote : represents notes.","title":"Main musical concepts"},{"location":"internals/arclasses/#utilities","text":"ARFactory : this class is in charge of the creation of all the musical elements (voices, notes, tags,...). It is used either by the parser of by the GUIDOFactory API . ARMusicalVoiceState : used to maintain the current voice state at a given location when traversing the voice. For example, a voice state contains the list of opened tags at a given voice position.","title":"Utilities"},{"location":"internals/arclasses/#ar-to-ar-operations","text":"AR to AR operations enrich the abstract representation with elements that can be automatically computed from the current descrption (e.g. like bars). They consists also in a set of logical layout operations (e.g. compute the beam direction when not set). Theses operations are implemented in ARMusicalVoice by a set of methods named doAuto... : doAutoKeys(): traverses the voice and look for key changes. Whenever a key-change occurs, the previous key needs to be 'naturalized', doAutoDispatchLyrics(): converts lyrics tags into individual text-tags for all events within the range, doAutoTies(): traverses the voice and split ties so that there are always TWO events within a tie-Range, doAutoCheckStaffStateTags(): makes sure that clef/key/meter-information is set, doAutoDisplayCheck(): checks whether the events in the voice can be displayed as single graphical objects, doAutoBarlines(): add automatic barlines, breaks notes if needed, doAutoMeasuresNumbering(): add mesaures numbering, doAutoEndBar(): add end bar (unless prevented with an auto tag), doAutoBeaming(): add automatic beaming tags, doAutoGlissando(): post-processing for the glissando tags, doAutoFeatheredBeam(): post-processing for the fbeam tags.","title":"AR to AR operations"},{"location":"internals/grclasses/","text":"Graphic classes Graphic classes are graphic instances of the abstract classes , i.e. notation elements with concrete graphic attributes (position, size, etc.). Almost each abstract class has a corresponding graphic classe which is implemented in a file that starts with 'GR' and that carries the name of the class. For example, the GRMeter.cpp file implements the graphic instance of the ARMeter class, that handles the \\meter tag. Structure of the GR Class GRMusic : one instance of this class is created for every score. GRMusic contains one or more instances of class GRPage, which represent the pages of the score. To create the pages and lines of a score, GRMusic uses the GRStaffManager class. Class GRPage contains one or more instances of class GRSystem. An instance of class GRPage knows about its height and width and also about the size of its margins. Some graphical elements of the score, like for instance the visible title and composer of a piece are also controlled by class GRPage. Class GRSystem represents a line of music in the score. It is made up of one or more instances of class GRSystemSlice. When the line breaking algorithm has decided which slices belong to a system, class GRSystem must adjust the spacing of the notation elements, and must also adjust its extent to match the desired line width. Class GRSystemSlice is a part of a single line of music. A set of GRSystemSlices build a GRSystem. It is convenient to think of system slices as measures of a score. Class GRSystemSlice contains one or more instances of class GRStaff. GRSystemSlice is also responsible for graphical elements that belong to several staves; this might be, for example, a beam that begins and ends in different staves. Class GRStaff represents a part of a single staff of a line of music. The time position and duration of the part being represented by an instance of class GRStaff is directly determined by the containing GRSystemSlice. Class GRStaff directly inherits from class GRCompositeNotationElement, which is capable of storing an arbitrary number of instances of class GRNotationElement. Using this storage, class GRStaff stores graphical elements being placed upon it. This might be musical markup, like for example an instance of class GRClef or a musical event like an instance of class GRNote. The main classes involved in the transformation of AR to GR are the GRStaffManager.cpp and the GRVoiceManager.cpp Main classes Class GRTag : the base class for all GUIDO-tags. Class GRPositionTag : the base class for representing range tags (i.e. tags applied to a series of notes, e.g. \\slur(a b c). The issue of line breaking is crucial when dealing with range tags: if both the begin- and end-event of a range tag are located on one line of music, the graphical object (e.g. a slur) can be created directly. If the begin- and end-event of a range-tag are located on different lines, then the graphical object must be split into several graphical objects. A mechanism within class GRPositionTag has been implemented to deal with this case. Class GNotationElement : the base class for all graphical elements. It covers elements that corresponds to an AR object with the derived GARNotationElement class, as well as elements that have no explicit description (like beams, stems, notehead, etc.) Class GRARNotationElement : the base class for all graphical objects that have a direct counterpart in the Abstract Representation (which is shown by using \u201cAR\u201d as part of the name). Consider, for example, class GRClef, which inherits indirectly from class GRTag and from class GRARNotationElement. This reflects, that the graphical \u201cclef \u201d object has a direct counterpart in the AR (which obviously is an instance of the class ARClef). Note Within the GR representation, all references to an AR object are const. Thus a GR object can't modify the AR representation.","title":"GR classes"},{"location":"internals/grclasses/#graphic-classes","text":"Graphic classes are graphic instances of the abstract classes , i.e. notation elements with concrete graphic attributes (position, size, etc.). Almost each abstract class has a corresponding graphic classe which is implemented in a file that starts with 'GR' and that carries the name of the class. For example, the GRMeter.cpp file implements the graphic instance of the ARMeter class, that handles the \\meter tag.","title":"Graphic classes"},{"location":"internals/grclasses/#structure-of-the-gr","text":"Class GRMusic : one instance of this class is created for every score. GRMusic contains one or more instances of class GRPage, which represent the pages of the score. To create the pages and lines of a score, GRMusic uses the GRStaffManager class. Class GRPage contains one or more instances of class GRSystem. An instance of class GRPage knows about its height and width and also about the size of its margins. Some graphical elements of the score, like for instance the visible title and composer of a piece are also controlled by class GRPage. Class GRSystem represents a line of music in the score. It is made up of one or more instances of class GRSystemSlice. When the line breaking algorithm has decided which slices belong to a system, class GRSystem must adjust the spacing of the notation elements, and must also adjust its extent to match the desired line width. Class GRSystemSlice is a part of a single line of music. A set of GRSystemSlices build a GRSystem. It is convenient to think of system slices as measures of a score. Class GRSystemSlice contains one or more instances of class GRStaff. GRSystemSlice is also responsible for graphical elements that belong to several staves; this might be, for example, a beam that begins and ends in different staves. Class GRStaff represents a part of a single staff of a line of music. The time position and duration of the part being represented by an instance of class GRStaff is directly determined by the containing GRSystemSlice. Class GRStaff directly inherits from class GRCompositeNotationElement, which is capable of storing an arbitrary number of instances of class GRNotationElement. Using this storage, class GRStaff stores graphical elements being placed upon it. This might be musical markup, like for example an instance of class GRClef or a musical event like an instance of class GRNote. The main classes involved in the transformation of AR to GR are the GRStaffManager.cpp and the GRVoiceManager.cpp","title":"Structure of the GR"},{"location":"internals/grclasses/#main-classes","text":"Class GRTag : the base class for all GUIDO-tags. Class GRPositionTag : the base class for representing range tags (i.e. tags applied to a series of notes, e.g. \\slur(a b c). The issue of line breaking is crucial when dealing with range tags: if both the begin- and end-event of a range tag are located on one line of music, the graphical object (e.g. a slur) can be created directly. If the begin- and end-event of a range-tag are located on different lines, then the graphical object must be split into several graphical objects. A mechanism within class GRPositionTag has been implemented to deal with this case. Class GNotationElement : the base class for all graphical elements. It covers elements that corresponds to an AR object with the derived GARNotationElement class, as well as elements that have no explicit description (like beams, stems, notehead, etc.) Class GRARNotationElement : the base class for all graphical objects that have a direct counterpart in the Abstract Representation (which is shown by using \u201cAR\u201d as part of the name). Consider, for example, class GRClef, which inherits indirectly from class GRTag and from class GRARNotationElement. This reflects, that the graphical \u201cclef \u201d object has a direct counterpart in the AR (which obviously is an instance of the class ARClef).","title":"Main classes"},{"location":"internals/grclasses/#note","text":"Within the GR representation, all references to an AR object are const. Thus a GR object can't modify the AR representation.","title":"Note"},{"location":"internals/layout/","text":"Global steps of the layout Building the graphic representation is a complex task that involves spacing and line breaking, which depends on the elements bounding box and determines their horizontal position. Each element has also to compute its specific graphic properties (e.g. a curve for slurs or ties). Spacing and line breaking Spacing algorithm is based on a spring-rod model and line breaking algorithm is derived from Donald Knuth . In practice, the implementation of these algorithms suffers from old-fashioned coding: non-structured methods that are 200 to 500 lines long, lack of convention to differentiate local variables and class fields, non-functional implementation, in the form of a state machine. All this makes it almost impossible to modify these algorithms although they are perfectly described in Renz's thesis . The core of the spacing and line breaking is in charge of the GRStaffManager . Position and bounding box The common properties of all the graphic elements are their bounding box and their position. Computing these properties can be complex, in particular due to line breaks that can break an element into several parts, and also because of collisions that can occur with other elements. Only range tags are concerned with the former issue but all elements may have to face the latter. Note that originaly, the Guido Engine didn't made any provision to solve collisions but the Guido language was designed to solve them manually with common tag parameters like dx or dy , used for relative displacement of an element. The various uses of the Guido engine have gradually led to the inclusion of automatic systems for collision avoidance. Range tags The main method to compute the element graphic properties is tellPosition that each object inherits from GObject. The method interface is the following: virtual void tellPosition( GObject * caller, const NVPoint & position ); tellPosition is called twice with the first and last object of the tag range and with the corresponding object position. In addition and when a tag is split by a line break, the method is called for each segment. In this case, a GRSystemStartEndStruct can be used to collect information about the segments. In particular it contains a startflag and an endflag that indicates the status of the current segment (between LEFTMOST, RIGHTMOST, OPENLEFT, OPENRIGHT, NOTKNOWN). The GRSystemStartEndStruct must be allocated by the object constructor and added to the object start-end list using addSystemStartEndStruct . It can be retrieved using getSystemStartEndStruct(const GRSystem * grsystem) . Other tags The horizontal position of non-range tags is automatically set by the engine. The vertical position is to be computed by the object. Computing the bounding box mainly consists in getting glyphs extends. Automatic collision avoidance All the elements that inherits GRNotationElement have access to the list of associated GRNotationElement using getAssociations() . This list is typically associated to range tags and contains all the elements of the range (e.g. the notes covered by a slur). Typically, the bounding box of associated elements is used to detect and solve a collision. Non-range tags have no context and thus, they need to build their own contextual information in order to handle potential collisions. Drawing Each element is responsible to re-implement the OnDraw method which interface is the following: virtual void OnDraw( VGDevice & hdc ) const; The method is const and thus, all the computation regarding the layout has to be already performed before OnDraw is called. The default behaviour is to draw a music symbol for symbol based elements. Elements that have been segmented by a line break have access to the current drawing state using their GRSystemStartEndStruct . The method takes a Virtual Graphic Device as argument.","title":"Layout steps"},{"location":"internals/layout/#global-steps-of-the-layout","text":"Building the graphic representation is a complex task that involves spacing and line breaking, which depends on the elements bounding box and determines their horizontal position. Each element has also to compute its specific graphic properties (e.g. a curve for slurs or ties).","title":"Global steps of the layout"},{"location":"internals/layout/#spacing-and-line-breaking","text":"Spacing algorithm is based on a spring-rod model and line breaking algorithm is derived from Donald Knuth . In practice, the implementation of these algorithms suffers from old-fashioned coding: non-structured methods that are 200 to 500 lines long, lack of convention to differentiate local variables and class fields, non-functional implementation, in the form of a state machine. All this makes it almost impossible to modify these algorithms although they are perfectly described in Renz's thesis . The core of the spacing and line breaking is in charge of the GRStaffManager .","title":"Spacing and line breaking"},{"location":"internals/layout/#position-and-bounding-box","text":"The common properties of all the graphic elements are their bounding box and their position. Computing these properties can be complex, in particular due to line breaks that can break an element into several parts, and also because of collisions that can occur with other elements. Only range tags are concerned with the former issue but all elements may have to face the latter. Note that originaly, the Guido Engine didn't made any provision to solve collisions but the Guido language was designed to solve them manually with common tag parameters like dx or dy , used for relative displacement of an element. The various uses of the Guido engine have gradually led to the inclusion of automatic systems for collision avoidance.","title":"Position and bounding box"},{"location":"internals/layout/#range-tags","text":"The main method to compute the element graphic properties is tellPosition that each object inherits from GObject. The method interface is the following: virtual void tellPosition( GObject * caller, const NVPoint & position ); tellPosition is called twice with the first and last object of the tag range and with the corresponding object position. In addition and when a tag is split by a line break, the method is called for each segment. In this case, a GRSystemStartEndStruct can be used to collect information about the segments. In particular it contains a startflag and an endflag that indicates the status of the current segment (between LEFTMOST, RIGHTMOST, OPENLEFT, OPENRIGHT, NOTKNOWN). The GRSystemStartEndStruct must be allocated by the object constructor and added to the object start-end list using addSystemStartEndStruct . It can be retrieved using getSystemStartEndStruct(const GRSystem * grsystem) .","title":"Range tags"},{"location":"internals/layout/#other-tags","text":"The horizontal position of non-range tags is automatically set by the engine. The vertical position is to be computed by the object. Computing the bounding box mainly consists in getting glyphs extends.","title":"Other tags"},{"location":"internals/layout/#automatic-collision-avoidance","text":"All the elements that inherits GRNotationElement have access to the list of associated GRNotationElement using getAssociations() . This list is typically associated to range tags and contains all the elements of the range (e.g. the notes covered by a slur). Typically, the bounding box of associated elements is used to detect and solve a collision. Non-range tags have no context and thus, they need to build their own contextual information in order to handle potential collisions.","title":"Automatic collision avoidance"},{"location":"internals/layout/#drawing","text":"Each element is responsible to re-implement the OnDraw method which interface is the following: virtual void OnDraw( VGDevice & hdc ) const; The method is const and thus, all the computation regarding the layout has to be already performed before OnDraw is called. The default behaviour is to draw a music symbol for symbol based elements. Elements that have been segmented by a line break have access to the current drawing state using their GRSystemStartEndStruct . The method takes a Virtual Graphic Device as argument.","title":"Drawing"},{"location":"internals/src-code/","text":"Source code organisation The source code of the Guido Engine is located in the src/engine folder. This folder is organised as follows: Name description abstract contains all the abstract representation (AR) classes and tags parameters management classes. The file names for AR classes starts with AR . The file names for tags management classes starts with Tag alt-rep contains classes that implement alternate representations (PianoRoll and Reduced Proportional representations) devices contains the platform independent graphic devices like the SVG or the Abstract devices. Note that platform dependant devices are located in the platforms or in the environments folders. graphic contains all the graphic representation (GR) classes and some various utilities. The file names for GR classes starts with GR . include contains the public header files. lib contains the C++ interface implementation and various utilities. maps contains the time to graphic mapping implementation misc contains various shared utilities. operations contains operations on AR or GR representations. parser contains the Guido Music Notation parser definition and implementation. tools various utilities mainly for debug purpose.","title":"Source code organisation"},{"location":"internals/src-code/#source-code-organisation","text":"The source code of the Guido Engine is located in the src/engine folder. This folder is organised as follows: Name description abstract contains all the abstract representation (AR) classes and tags parameters management classes. The file names for AR classes starts with AR . The file names for tags management classes starts with Tag alt-rep contains classes that implement alternate representations (PianoRoll and Reduced Proportional representations) devices contains the platform independent graphic devices like the SVG or the Abstract devices. Note that platform dependant devices are located in the platforms or in the environments folders. graphic contains all the graphic representation (GR) classes and some various utilities. The file names for GR classes starts with GR . include contains the public header files. lib contains the C++ interface implementation and various utilities. maps contains the time to graphic mapping implementation misc contains various shared utilities. operations contains operations on AR or GR representations. parser contains the Guido Music Notation parser definition and implementation. tools various utilities mainly for debug purpose.","title":"Source code organisation"},{"location":"internals/tagparams/","text":"Tag Parameters All the tags parameters are declared in the src/engine/abstract/TagParameterStrings.cpp file. It consists in a set of constant strings, consistently named according to the AR class that uses the parameters. For example: tag parameters for the ARMeter class is named kARMeterParams . Tag parameters string A tag parameters string is a list of semicolon separated parameters. Each parameter is a string in the following format: \"TYPE,NAME,DEFVALUE,REQUIRED\" where: TYPE is the parameter type and must be in: 'U' : a unit parameter i.e. a numeric value with an optional unit ('cm', 'hs',...). When omitted, the default unit is used. 'S' : a string parameter. 'I' : an integer parameter. 'F' : a float parameter. NAME is the parameter name. DEFVALUE is the parameter default value. REQUIRED is either 'r' or 'o' for required or optional parameters. Example: The ARMeter tag parameters are described with: \"S,type,4/4,r;S,autoBarlines,on,o;S,autoMeasuresNum,off,o;S,group,off,o\" see the \\meter documentation for the parameters description. Shared Parameters The following parameters are shared by all the AR classes: const char* kCommonParams = \"S,color,black,o;U,dx,0,o;U,dy,0,o;F,size,1.0,o\"; The following parameters are shared by all the ARFontAble derived classes: const char* kARFontAbleParams = \"S,textformat,rc,o;S,font,Times,o;U,fsize,9pt,o;S,fattrib,,o\"; Initialisation All the tag parameters strings are stored in a TagParametersMaps structure that is initialised by GuidoInit() and released by GuidoShutdown() . Each AR class is responsible to: setup its parameters at construction time using setupTagParameters (_a_param_map_) handle the current parameters by overriding the setTagParameters method For example, see the ARFermata implementation. Creating a new parameters string It requires the following steps: implement the new parameter string in TagParameterStrings.cpp declare the new string in TagParameterStrings.h add a new parameters map in TagParametersMaps.h","title":"Tag Parameters"},{"location":"internals/tagparams/#tag-parameters","text":"All the tags parameters are declared in the src/engine/abstract/TagParameterStrings.cpp file. It consists in a set of constant strings, consistently named according to the AR class that uses the parameters. For example: tag parameters for the ARMeter class is named kARMeterParams .","title":"Tag Parameters"},{"location":"internals/tagparams/#tag-parameters-string","text":"A tag parameters string is a list of semicolon separated parameters. Each parameter is a string in the following format: \"TYPE,NAME,DEFVALUE,REQUIRED\" where: TYPE is the parameter type and must be in: 'U' : a unit parameter i.e. a numeric value with an optional unit ('cm', 'hs',...). When omitted, the default unit is used. 'S' : a string parameter. 'I' : an integer parameter. 'F' : a float parameter. NAME is the parameter name. DEFVALUE is the parameter default value. REQUIRED is either 'r' or 'o' for required or optional parameters.","title":"Tag parameters string"},{"location":"internals/tagparams/#example","text":"The ARMeter tag parameters are described with: \"S,type,4/4,r;S,autoBarlines,on,o;S,autoMeasuresNum,off,o;S,group,off,o\" see the \\meter documentation for the parameters description.","title":"Example:"},{"location":"internals/tagparams/#shared-parameters","text":"The following parameters are shared by all the AR classes: const char* kCommonParams = \"S,color,black,o;U,dx,0,o;U,dy,0,o;F,size,1.0,o\"; The following parameters are shared by all the ARFontAble derived classes: const char* kARFontAbleParams = \"S,textformat,rc,o;S,font,Times,o;U,fsize,9pt,o;S,fattrib,,o\";","title":"Shared Parameters"},{"location":"internals/tagparams/#initialisation","text":"All the tag parameters strings are stored in a TagParametersMaps structure that is initialised by GuidoInit() and released by GuidoShutdown() . Each AR class is responsible to: setup its parameters at construction time using setupTagParameters (_a_param_map_) handle the current parameters by overriding the setTagParameters method For example, see the ARFermata implementation.","title":"Initialisation"},{"location":"internals/tagparams/#creating-a-new-parameters-string","text":"It requires the following steps: implement the new parameter string in TagParameterStrings.cpp declare the new string in TagParameterStrings.h add a new parameters map in TagParametersMaps.h","title":"Creating a new parameters string"},{"location":"internals/vgdevice/","text":"Virtual Graphic Devices The core of the Guido Engine is platform independent. Only the graphic operations and font related operations depend on the host operating system and graphic layers. In order to cope with each specific platform, the Guido library provides a Virtual Graphic Device layer which is actually a set of pure C++ abstract classes that isolates the engine from the platform dependencies. The main advantage is that Virtual Graphic Devices can implement any kind of graphic output: on-screen (platform specific, OpenGL), off-screen (raw bitmaps), files (pdf, svg, postscript), network streams, etc. The Virtual Graphic classes The VG classes are located in the src/engine/include folder and are the following: VGDevice : declares all methods required by the Guido Graphic Representation (GGR) to communicate their graphical operations. Implementations of VGDevices are provided by clients applications using derived classes so that neither GGR objects nor any part of the GUIDO Engine depends on a particular graphical implementation. A VGDevice derived classe must provide standard graphic functions (Lines, Arcs, Boxes,Polygons, Text), coordinate transformations (zoom / scaling), and symbolic music symbols handlers (DrawSymbol method). VGDevice design makes a clear distinction between text characters and music symbols (although music symbols are generally glyphs in a music font). Music symbols are identified by font-independent constants defined in MusicalSymbols.h . VGFont : provides font related information like glyphs metrics, VGSystem : an abstract layer providing VGDevice and VGFont allocation. In addition, two utilities are provided: VGColor and VGPen covering respectively colors and pen representations. Implementations Platform specific Platform specific implementations of VGDevice are located in the platforms folder: linux/src: implements a Cairo based device, macos/src: implements a Quartz based device, win32/src: contains several implementations: a GDI based device a GDI Plus based device a Direct 2D based device Platform independent Platform independent implementations of VGDevice are located in the src/engine/devices folder: SVG device: produces SVG output Abstract device: produces VGDevice commands on output. Actually prints the VGDevice methods followed by their parameters. This output can next be parsed by another component implementing the VGDevice interface, to execute the enclosed methods. This splits the graphics rendering into two distinct parts. This is useful, for example, under Android to communicate between the native layer that calculates the partition and the Java layer that draws the result of this calculation. Binary device: similar to the Abstract device but in a more compact binary form. Environment dependent A set of VGDevices are implemented over already platform independent layers and provide compatibility with various high level frameworks. They are located in the environments folder: Juce : implements a device based on the Juce framework, OpenFrameworks : implements a device over OpenFramework OpenGL : implements a device based on OpenGl. Requires also freetype2 and FTGL (OpenGL FreeType fonts) libraries, Qt : implements a device based on the Qt framework. Unsupported implementations GDeviceWin2000: Windows 2000 / XP(gdi+) GDeviceGTK: Linux GTK implementation GDevicePostScript: EPS files (encapsulated postscript)","title":"The VGDevice layer"},{"location":"internals/vgdevice/#virtual-graphic-devices","text":"The core of the Guido Engine is platform independent. Only the graphic operations and font related operations depend on the host operating system and graphic layers. In order to cope with each specific platform, the Guido library provides a Virtual Graphic Device layer which is actually a set of pure C++ abstract classes that isolates the engine from the platform dependencies. The main advantage is that Virtual Graphic Devices can implement any kind of graphic output: on-screen (platform specific, OpenGL), off-screen (raw bitmaps), files (pdf, svg, postscript), network streams, etc.","title":"Virtual Graphic Devices"},{"location":"internals/vgdevice/#the-virtual-graphic-classes","text":"The VG classes are located in the src/engine/include folder and are the following: VGDevice : declares all methods required by the Guido Graphic Representation (GGR) to communicate their graphical operations. Implementations of VGDevices are provided by clients applications using derived classes so that neither GGR objects nor any part of the GUIDO Engine depends on a particular graphical implementation. A VGDevice derived classe must provide standard graphic functions (Lines, Arcs, Boxes,Polygons, Text), coordinate transformations (zoom / scaling), and symbolic music symbols handlers (DrawSymbol method). VGDevice design makes a clear distinction between text characters and music symbols (although music symbols are generally glyphs in a music font). Music symbols are identified by font-independent constants defined in MusicalSymbols.h . VGFont : provides font related information like glyphs metrics, VGSystem : an abstract layer providing VGDevice and VGFont allocation. In addition, two utilities are provided: VGColor and VGPen covering respectively colors and pen representations.","title":"The Virtual Graphic classes"},{"location":"internals/vgdevice/#implementations","text":"","title":"Implementations"},{"location":"internals/vgdevice/#platform-specific","text":"Platform specific implementations of VGDevice are located in the platforms folder: linux/src: implements a Cairo based device, macos/src: implements a Quartz based device, win32/src: contains several implementations: a GDI based device a GDI Plus based device a Direct 2D based device","title":"Platform specific"},{"location":"internals/vgdevice/#platform-independent","text":"Platform independent implementations of VGDevice are located in the src/engine/devices folder: SVG device: produces SVG output Abstract device: produces VGDevice commands on output. Actually prints the VGDevice methods followed by their parameters. This output can next be parsed by another component implementing the VGDevice interface, to execute the enclosed methods. This splits the graphics rendering into two distinct parts. This is useful, for example, under Android to communicate between the native layer that calculates the partition and the Java layer that draws the result of this calculation. Binary device: similar to the Abstract device but in a more compact binary form.","title":"Platform independent"},{"location":"internals/vgdevice/#environment-dependent","text":"A set of VGDevices are implemented over already platform independent layers and provide compatibility with various high level frameworks. They are located in the environments folder: Juce : implements a device based on the Juce framework, OpenFrameworks : implements a device over OpenFramework OpenGL : implements a device based on OpenGl. Requires also freetype2 and FTGL (OpenGL FreeType fonts) libraries, Qt : implements a device based on the Qt framework.","title":"Environment dependent"},{"location":"internals/vgdevice/#unsupported-implementations","text":"GDeviceWin2000: Windows 2000 / XP(gdi+) GDeviceGTK: Linux GTK implementation GDevicePostScript: EPS files (encapsulated postscript)","title":"Unsupported implementations"},{"location":"papers/","text":"Pubications related to the Guido Project H. Hoos, K. Hamel, K. Renz, and J. Kilian. The GUIDO Music Notation Format - a Novel Approach for Adequately Representing Score-level Music. In Proceedings of the International Computer Music Conference, pages 451\u2013454. ICMA, 1998. K. Renz and H. Hoos. A Web-based Approach to Music Notation Using GUIDO . In Proceedings of the International Computer Music Conference, pages 455\u2013458. ICMA, 1998. K. Renz. Algorithms and Data Structures for a Music Notation System based on GUIDO Music Notation. PhD thesis, Technischen Universit\u00e4t Darmstadt, 2002. K. Renz. An improved algorithm for spacing a line of music. In Proceedings of International Computer Music Conference, pages 475\u2013481, 2002. C. Daudin, D. Fober, S. Letz, and Y. Orlarey. The Guido Engine \u2013 A toolbox for music scores rendering. In Proceedings of Linux Audio Conference 2009, pages 105\u2013111, 2009. D. Fober, Y. Orlarey, and S. Letz. Scores Level Composition Based on the Guido Music Notation. In ICMA, editor, Proceedings of the International Computer Music Conference, pages 383\u2013386, 2012. C. Le Roi, C. Decron, and D. Fober. Extension de Guido aux notations contemporaines. In Actes des Journ\u00e9es d\u2019Informatique Musicale, pages 17\u201324, Bourges, France, 2014.","title":"Articles"},{"location":"papers/#pubications-related-to-the-guido-project","text":"H. Hoos, K. Hamel, K. Renz, and J. Kilian. The GUIDO Music Notation Format - a Novel Approach for Adequately Representing Score-level Music. In Proceedings of the International Computer Music Conference, pages 451\u2013454. ICMA, 1998. K. Renz and H. Hoos. A Web-based Approach to Music Notation Using GUIDO . In Proceedings of the International Computer Music Conference, pages 455\u2013458. ICMA, 1998. K. Renz. Algorithms and Data Structures for a Music Notation System based on GUIDO Music Notation. PhD thesis, Technischen Universit\u00e4t Darmstadt, 2002. K. Renz. An improved algorithm for spacing a line of music. In Proceedings of International Computer Music Conference, pages 475\u2013481, 2002. C. Daudin, D. Fober, S. Letz, and Y. Orlarey. The Guido Engine \u2013 A toolbox for music scores rendering. In Proceedings of Linux Audio Conference 2009, pages 105\u2013111, 2009. D. Fober, Y. Orlarey, and S. Letz. Scores Level Composition Based on the Guido Music Notation. In ICMA, editor, Proceedings of the International Computer Music Conference, pages 383\u2013386, 2012. C. Le Roi, C. Decron, and D. Fober. Extension de Guido aux notations contemporaines. In Actes des Journ\u00e9es d\u2019Informatique Musicale, pages 17\u201324, Bourges, France, 2014.","title":"Pubications related to the Guido Project"}]}